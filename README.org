#+title: Everlay

[[./assets/20230401-restaurants.jpg][Screenshot of simulation running in the logs]]


* inspirations
First in plain text metaphors in poems. A falling apple is a falling knowledge is a crushing meteorite is an elevator.

Then a mobile game that overlayed monsters over phone camera such that you could shoot them when you saw them in the room.

Then a browser game named something like "is your pepper long" that increased the size of a pepper animation based on some activity like clicking or liking.

Then a watch face which represented hours from birth.

Then 2D games with detailed simulation, multiplayer agency and emergent gameplay.

Then simulators that represented human market behaviour as system (liquid) dynamics.

Applicative and monoid behaviour around us, category theory

Platforms for collaborative dashboards and analytics of distributed systems.

Then the distributed system, complex behavior open for public analysis, games as overlays over public distributed systems

Contemplation of novel compsci application leads back to it
* models to model
- sephiroth tree
- five buddhism
- vera & mera
* example
A gnome that fights with other gnomes based on operations of transfer and trait of Even/Odd.

Let's say there's addition, subtraction and identification

So generate a custom gnome face from identification

And they turn evil if their number is odd

And good if their number is even

And each time there is transfer between two gnomes, they can either switch sides or stay

And if they both stay in one camp afterwards we say that they are agreeing

And if they both switched sides we say they fought


This is a kind of overlay for sure, and yet it doesnt' make apparent the composability.

Provide a toolchain, a constructor UI that lets people set traits to features and see the outcome.

User picks overlays "gnome" and "fight", and sets them to devices, and show public activity as that.


Under the hood there's toolchain for matching all monoid devices to monoid overlays

Automated market maker trade operation implements addition, overlay of growing tree implements addition

Connect some overlay to automated market maker

And see trade as gnome wars, or as fish swimming in sea, or as trees growing

And see a forest instead of explorer transactions


Program an addition device, plug it to some source, plug it to some overlay, and a tree would grow on the server when some public API values change


A simulation is where device logic is implemented by an expression instead of connecting to a public API source

Before connecting to API that implmenents addition and subtraction over time, and trying to display fibonacci retracement levels, implement a device with a fibonacci sequence and test overlays against that simulation
